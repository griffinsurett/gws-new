---
// src/pages/[collection]/[slug].astro
import { getCollection } from "astro:content";
import { Image } from "astro:assets";
import Heading from "@/components/Heading.jsx";
import Section from "@/components/Section/Section.astro";
import { collections } from "@/content/config";
import { getCollectionMeta } from "@/utils/FetchMeta";
import { getCanonicalSlug } from "@/utils/ContentUtils";

// 1) Build static paths
export async function getStaticPaths() {
  const names = Object.keys(collections);
  const paths: Array<{ params: { collection: string; slug: string }; props: any }> = [];

    // 1) Build static paths based solely on itemsHasPage  per-entry hasPage
  for (const coll of names) {
    // load collection-level meta; default to true if missing
    let meta;
    try {
      meta = getCollectionMeta(coll);
    } catch {
      meta = {};
    }

    // if *no* item pages should ever be generated for this collection, skip it entirely
    if (meta.itemsHasPage === false) continue;

    const entries = await getCollection(coll);
    entries
      // skip any entry whose own frontmatter hasPage === false
      .filter((entry) => entry.data.hasPage !== false)
      .forEach((entry) => {
        paths.push({
          params: { collection: coll, slug: getCanonicalSlug(entry) },
          props: { collection: coll, entry },
        });
      });
  }

  return paths;
}

const { collection, entry } = Astro.props;
const { data, body } = entry;

// Safely load page-specific meta
let meta;
try {
  meta = getCollectionMeta(collection);
} catch {
  meta = {};
}

// 2) Default layout specifier (must match the glob keys)
const spec =
  meta.itemsLayout || meta.layout || "../../layouts/BaseLayout.astro";

// 3) Register all layouts two levels up
const layoutImporters = import.meta.glob("../../layouts/**/*.astro");

// 4) Lookup and import the chosen layout
const importer = layoutImporters[spec];
if (!importer) {
  throw new Error(`Unknown layout specifier: ${spec}`);
}
const { default: Layout } = await importer();

// 5) Resolve sections
const sections = data.sections?.length ? data.sections : meta.itemsSections || [];

let Content = null;
if (typeof entry.render === "function") {
  const rendered = await entry.render();
  Content = rendered.Content;
}
console.log("robots", data.robots);
---

<Layout
  collection={collection}
  entry={entry}
  title={data.title}
  description={data.description}
  keywords={data.keywords}
  ogType={data.ogType}
  robots={data.robots}
>
  {Content && <Content />}
  {sections.map((section, i) => (
    <Section
      key={i}
      variant={section.variant}
      collection={section.collection}
      query={section.query}
      heading={section.heading}
      description={section.description}
      descriptionClass={section.descriptionClass}
      buttons={section.buttons}
      sectionClass={section.sectionClass}
      contentClass={section.contentClass}
      itemsClass={section.itemsClass}
      itemClass={section.itemClass}
      buttonsSectionClass={section.buttonsSectionClass}
      headingAreaClass={section.headingAreaClass}
      {...section}
    />
  ))}
</Layout>
